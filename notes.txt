TODO:

	state separation all nice, but how do we handle the buffers, extra or not? who listens to what?
		Graphics object provides buffers for writing/updates
		
		// Renders player info and log in given area,  with the gui shader
		RenderGui(rect)
		
		// Renders the regular game view with the dense shader
		RenderGame(rect)
		
		// Renders this buffer at the given rect with the gui shader (e.g. inventory)
		RenderGameOverlay(rect, buffer)	
		
		// Renders this buffer at the given rect with the highlighting shader (e.g. cursor, target locations)
		RenderGameOverlayHighlighted(rect, buffer)	
		
		// Renders a fullscreen background image, with the dense shader
		RenderBg(rect)
		
		// Renders a menu
		RenderMenu(buffer)

	? How, after targetting, we know how to resume with any action that required targetting?
		input handling and GUI go together. Static classes maybe, or via a state stack

	ranged attack support + look support
		"T" targets for ranged weapons
			takes over arrow keys
			allow to MOVE the cursor anywhere, but only confirm on visible tiles (maybe highlight w/ color)
		when projectile is fired, render all distinct points in the path, N times per frame (default to 2) WHILE other things are happening -- who cares
	
	"actions": no
	
	refactor w/ signals-slots library
	
	save/load via json
	
	in db.cpp, add a function to manually create some entities (inc.player) -- useful for pre-json stuff
	
	main menu

Rationale:
	Trying to keep things simple, sometimes at the expense of doing things "properly" or efficiently
	no templates, no shared pointers

Codebase:
	Graphics:
		Select tile size (based e.g. on bitmap font)
			Determine game grid size
			Expose simple functions such as:
			void SetTile(ivec2 position, int layerId, Tile tile) // layer info bad?
			void SetBackgroundImage( string filename )
			
			int2 CursorPosition(), in Input class really
			
		Simple classes/enums like:
			TileMap: a handle on the texture, plus info on what it contains ( default layer)
			Tile: tile index, plus optional tint and optional layer override
			Layer: Background, Objects, Creatures, Effects, FogOfWar, Gui
			
		It's worth to have a resizable buffer class (realloc at 2x capacity when growing)
			
			
	Game state:
		Different screens are different update/render loops
		Single global game state that stores info about the game
		
		Basic widgets, e.g. buttons with different rendering for pressed/unpressed
		
	ECS:
		
		Common entity data:
			name
			Render info
				array of Tiles (that's constant data, at entity creation)
				current tile (default to 0, changes as needed)
		
		Entity types:
			Creature:
				position
				location
				container
				equipment
				hp
			Item
				weight
				value
				owner
				stackSize = 1
				
				useInfo // can it be Used
				meleeInfo // can it be wielded as a melee weapon?
				throwInfo // can it be thrown?
				rangedInfo // can it be used as a ranged weapon?
				ammoInfo // can it be used as ammo?
				armorInfo // can it be used as armor?
			Object
				position
				location
				blocksVision
				blocksMovement
				
				bool canInteractFromAdjacentTile = true
				
				virtual void OnInteractWith()
				
				Subclasses:
					Container
					Fountain
					Door
					Stairs
						stores connecting stairs id/name (name is easier as it doesn't require pre-instantiation, e.g. "stairs to level 1b")
						
			SpawnInfo class: configuration to assist with instantiation of an entity:
				static info in database (render tiles, etc)
				dynamic info as parameters (position, location, etc)
				
	GUI and interactions:
		Melee, target, area of effect display
						

					

Part 0 - Setting Up
Part 1 - Drawing the ‘@’ symbol and moving it around
Part 2 - The generic Entity, the render functions, and the map
Part 3 - Generating a dungeon
Part 4 - Field of view
Part 5 - Placing enemies and kicking them (harmlessly)
Part 6 - Doing (and taking) some damage
Part 7 - Creating the Interface
Part 8 - Items and Inventory
Part 9 - Ranged Scrolls and Targeting
Part 10 - Saving and loading
Part 11 - Delving into the Dungeon
Part 12 - Increasing Difficulty
Part 13 - Gearing up
